require 'shared_token_grammar'
require 'dadl_grammar'
require 'cadl_grammar'
require 'adl'

module OpenEHR
  module Parser
    grammar ADLGrammar

      include SharedToken
      include DADLGrammar
      include CADL

      rule archetype 
        arch_identification 
        spec:(arch_specialisation)?
        arch_concept
        lang:(arch_language)?
        desc:(arch_description)?
        arch_definition
        arch_invariant?
        arch_ontology {
          def archetype_id
            arch_identification.archetype_id
          end

          def adl_version
            arch_identification.adl_version
          end

	  def concept
	    arch_concept.value
	  end

	  def original_language
            tid, la = lang.original_language.split('::')
            OpenEHR::RM::DataTypes::Text::CodePhrase.new(
              :terminology_id => 
                OpenEHR::RM::Support::Identification::TerminologyID.new(:value => tid),
              :code_string => la)
          end

          def translations
            lang.translations
          end

          def description
            desc.value unless desc.empty?
          end

          def definition
            arch_definition.value
          end

          def ontology
            arch_ontology.value
          end
        }
      end

      rule arch_identification
        head:arch_head id:V_ARCHETYPE_ID space {
	  def archetype_id
            id.value
	  end

	  def adl_version
	    head.value[:adl_version]
	  end

          def is_controlled?
            head.value[:is_controlled?]
          end
        }
      end

      rule arch_head
        SYM_ARCHETYPE m:arch_meta_data {
	  def value
            m.value
	  end
	}
      / SYM_ARCHETYPE {
          def value
            Hash.new
          end
        }
      end

      rule arch_meta_data
        '(' arch_meta_data_items ')' space {
	   def value
             arch_meta_data_items.value
           end
         }
      end

      rule arch_meta_data_items
        item:arch_meta_data_item other_item:(';' arch_meta_data_item)* {
          def value
	    v = item.value
            other_item.elements.map {|i| i.arch_meta_data_item.value}
            v
	  end
        }
      end

      rule arch_meta_data_item
        SYM_ADL_VERSION SYM_EQ ver:V_VERSION_STRING space {
	  def value
            {:adl_version => ver.value}
          end
        }
      / SYM_IS_CONTROLED space {
          def value
	    {:is_controled? => true} # if elements[0]
          end
        }
      end

      rule arch_specialisation
        SYM_SPECIALIZE arch_id:V_ARCHETYPE_ID space {
	  def specialised?
	    true if elements[0]
          end

	  def archetype_id
	    arch_id.value
	  end
        }
      end

      rule arch_concept
        SYM_CONCEPT conc:V_LOCAL_TERM_CODE_REF space {
	  def value
            conc.text_value[1..-2]
          end
	}
      end

      rule arch_language
        SYM_LANGUAGE lang:V_DADL_TEXT <ArchLanguage>
      end

      rule arch_description
        SYM_DESCRIPTION desc:V_DADL_TEXT space {
          def value
            params = desc.value
            details = { }
            params[:details].each do |lang, attrs|
              term_id, la = attrs[:language].split('::')
              terminology_id = 
                OpenEHR::RM::Support::Identification::TerminologyID.new(
                  :value => term_id)
              misuse = attrs[:misuse].empty? ? nil : attrs[:misuse]
              item =
                OpenEHR::RM::Common::Resource::ResourceDescriptionItem.new(
                  :language => OpenEHR::RM::DataTypes::Text::CodePhrase.new(
                                :terminology_id => terminology_id,
                                :code_string => la),
                  :purpose => attrs[:purpose],
                  :keywords => attrs[:keywords],
                  :use => attrs[:use],
                  :misuse => misuse,
                  :copyright => attrs[:copyright],
                  :original_resource_uri => attrs[:original_resource_uri],
                  :other_details => attrs[:other_details])
              details[lang.to_s] = item
            end
            oc = params[:other_contributors].nil? ? nil : params[:other_contributors].values
            original_author = key_s params[:original_author]
            other_details = key_s params[:other_details] if params[:other_details] 
            OpenEHR::RM::Common::Resource::ResourceDescription.new(
              :original_author => original_author,
              :other_contributors => oc,
              :lifecycle_state => params[:lifecycle_state],
              :details => details,
              :resource_package_uri => params[:archetype_package_uri],
              :other_details => other_details)
          end

          def key_s(hash)
            hash.inject({ }) {|h,i| h.update Hash[i[0].to_s,i[1]]}
          end
        }
      end

      rule arch_definition
        SYM_DEFINITION definition:V_CADL_TEXT space {
          def value
            definition.value
          end
        }
      end

      rule arch_invariant
        SYM_INVARIANT V_ASSERTION_TEXT space
      end

      rule arch_ontology
        SYM_ONTOLOGY ontology:V_DADL_TEXT space {
          def value
            ao = ontology.value[:term_definitions]
            term_definitions = {}
            ao.each do |lang, term_defs|
              items = term_defs[:items]
              terms = items.map do |code, item|
                OpenEHR::AM::Archetype::Ontology::ArchetypeTerm.new(
                  :code => code.to_s, :items => item)
              end
              term_definitions[lang.to_s] = terms
            end
            OpenEHR::AM::Archetype::Ontology::ArchetypeOntology.new(
              :term_definitions => term_definitions)
          end
        }
      end
    end
  end
end
