require 'shared_token_grammar'

module OpenEHR
  module Parser
    grammar CADL

      include SharedToken

      rule V_CADL_TEXT
        c_complex_object '' {
          def value
            c_complex_object.value
          end
        }
      / assertions {
          def value
            assertions.value
          end
        }
      end

      rule c_complex_object
        head:c_complex_object_head SYM_MATCHES SYM_START_CBLOCK body:c_complex_object_body SYM_END_CBLOCK {
          def value
            head.value + body.value
          end
        }
      / c_complex_object_head {
          def value
            c_complex_object_head.value
          end
        }
      end

      rule c_complex_object_head
        c_complex_object_id c_occurrences {
          def value
            c_complex_object_id.value + c_occurrences.value
          end
        }
      / c_complex_object_id '' {
          def value
            c_complex_object_id.value
          end
        }
      end

      rule c_complex_object_id
        ti:type_identifier lo:V_LOCAL_TERM_CODE_REF space {
          def value
            {:rm_type_name => ti.value,
             :node_id => lo.value}
          end
        }
      / ti:type_identifier space {
          def value
            {rm_type_name => ti.value}
          end
        }
      end

      rule c_complex_object_body
        c_any '' {
          def value
            c_any.value
          end
        }
      / c_attributes {
          def value
            p c_attributes
            c_attributes.value
          end
        }
      end

      rule c_object
        c_complex_object
      / archetype_slot
      / archetype_internal_ref
      / constraint_ref
      / c_primitive_object
      / V_C_DOMAIN_TYPE
#     / ERR_V_C_DOMAIN_TYPE
      end

      rule archetype_internal_ref
        SYM_USE_NODE type_identifier c_occurrences? object_path
      end

      rule archetype_slot
        c_archetype_slot_head SYM_MATCHES SYM_START_CBLOCK c_includes? c_excludes? SYM_END_CBLOCK
      end

      rule c_archetype_slot_head
        c_archetype_slot_id white_space c_occurrences?
      end

      rule c_archetype_slot_id
        SYM_ALLOW_ARCHETYPE type_identifier V_LOCAL_TERM_CODE_REF?
      end

      rule c_primitive_object
        c_primitive
      end

  rule c_primitive
    c_integer
  / c_real
  / c_date
  / c_time
  / c_date_time
  / c_duration
  / c_string
  / c_boolean
  end

      rule c_any
        '*' space {
          def value
            '*'
          end
        }
      end

      rule c_attributes
        c_attribute+ {
          def value
            p elements
          end
        }
      end

  rule c_attribute
    c_attr_head c_attr_body {
      def value
        p elements
      end
    }
  end

  rule c_attr_head
     V_ATTRIBUTE_IDENTIFIER white_space c_existence? c_cardinality? 
  end

  rule c_attr_body
    SYM_MATCHES SYM_START_CBLOCK c_attr_values SYM_END_CBLOCK
  end

  rule c_attr_values
    c_any '' {
      def value
        c_any.text_value
      end
    }
  / c_object+ '' {
      def value
        elements.map { |e| p e}
      end
    }
  end

  rule c_includes
    SYM_INCLUDE assertions
  end

  rule c_excludes
    SYM_EXCLUDE assertions
  end

  rule c_existence
    SYM_EXISTENCE SYM_MATCHES SYM_START_CBLOCK existence_spec SYM_END_CBLOCK
  end

  rule existence_spec
    V_INTEGER (SYM_ELLIPSIS V_INTEGER)?
  end

  rule c_cardinality
    SYM_CARDINALITY SYM_MATCHES SYM_START_CBLOCK cardinality_spec SYM_END_CBLOCK {
      def value
        p elements
      end
    }
  end

  rule cardinality_spec
    occurrence_spec (';' white_space (SYM_UNORDERD / SYM_ORDERED) (';' white_space SYM_UNIQUE)?)?
  / occurrence_spec SYM_UNIQUE (';' white_space (SYM_ORDERED / SYM_UNORDERD))?
  end

  rule c_occurrences
    SYM_OCCURRENCES SYM_MATCHES SYM_START_CBLOCK occurrence_spec SYM_END_CBLOCK {
      def value
        occurrence_spec.value
      end
    }
  end

  rule occurrence_spec
    V_INTEGER SYM_ELLIPSIS cardinality_limit_value {
      def value
        p elements
      end
    }
  / cardinality_limit_value '' {
      def value
        p elements
      end
    }
  end

  rule cardinality_limit_value
    integer_value / '*'
  end

  rule c_integer_spec
    cardinality_limit_value
  / integer_list_value
  / integer_interval_value
  / occurrence_spec
  end

  rule c_integer
    c_integer_spec (';' integer_value)?
  end

  rule c_real_spec
    real_value
  / real_list_value
  / real_interval_value
  end

  rule c_real
    c_real_spec (';' real_value)?
  end

  rule c_date_constraint
    V_ISO8601_DATE_CONSTRAINT_PATTERN
  / date_value
  / date_interval_value
  end

  rule c_date
    c_date_constraint (';' date_value)?
  end

  rule c_time_constraint
    V_ISO8601_TIME_CONSTRAINT_PATTERN
  / time_value
  / time_interval_value
  end

  rule c_time
    c_time_constraint (';' time_value)?
  end

  rule c_date_time_constraint
    V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN
  / date_time_value
  / date_time_interval_value
  end

  rule c_date_time
    c_date_time_constraint
  / c_date_time_constraint ';' date_time_value
  end

      rule c_duration_constraint
        duration_pattern ('/' duration_interval_pattern)?
      / duration_value
      / duration_interval_value
      end

      rule duration_pattern
        V_ISO8601_TIME_CONSTRAINT_PATTERN
      end

      rule c_duration
        c_duration_constraint (';' duration_value)?
      end

      rule c_string_spec
        string_list_value (',' SYM_LIST_CONTINUE)?
      / V_REGEXP
      / V_STRING
      end

      rule c_string
        c_string_spec (';' string_value)?
      end

      rule c_boolean_spec
        SYM_TRUE (',' SYM_FALSE)?
      / SYM_FALSE (',' SYM_TRUE)?
      end

      rule c_boolean
        c_boolean_spec (';' boolean_value)?
      end

      rule constraint_ref
        V_LOCAL_TERM_CODE_REF
      end

      rule V_REGEXP
         (('=' / '!') '~')? (('/' ('\/' / !'/' .)* '/') / ('^' (!'^' .)* '^') )
      end

      rule V_C_DOMAIN_TYPE
        '('? [A-Z] IDCHAR* ')'? [ \n]* '<' [^>]* '>'
      end

# assertion block

      rule V_ASSETION_TEXT
        assertions {
          def value
            p elements
          end
        }
      end

      rule assertions
        assertion+ {
          def value
            p elements
          end
        }
      end

      rule assertion
        (any_identifier ':')? boolean_expression space {
          def value
            p elements
          end
        }
      end

      rule boolean_expression
        boolean_node
      end

      rule boolean_node
        SYM_EXISTS absolute_path
      / relative_path white_space SYM_MATCHES SYM_START_CBLOCK c_primitive SYM_END_CBLOCK
      / SYM_NOT boolean_leaf
      / arithmetic_expression (SYM_EQ / SYM_NE / SYM_LT / SYM_GT / SYM_LE / SYM_GE) arithmetic_expression
      / boolean_leaf ((SYM_AND / SYM_OR / SYM_XOR / SYM_IMPLIES) boolean_leaf)?
      end

      rule boolean_leaf
        '(' boolean_expression ')'
      / SYM_TRUE
      / SYM_FALSE
      end

      rule arithmetic_expression
        arithmetic_node
      end

      rule arithmetic_node
        arithmetic_leaf (('+' / '-' / '*' / '/' / '^') arithmetic_leaf)*
      end

      rule arithmetic_leaf
       '(' arithmetic_expression ')'
      / integer_value
      / real_value
      / absolute_path
      end


# path block
      rule movable_path
         SYM_MOVABLE_LEADER relative_path
      end

      rule absolute_path
        '/' relative_path?
      end

      rule relative_path
        path_segment ('/' path_segment)*
      end

      rule path_segment
        V_ATTRIBUTE_IDENTIFIER V_LOCAL_TERM_CODE_REF?
      end

      rule SYM_MOVABLE_LEADER
        '//'
      end
    end
  end
end
