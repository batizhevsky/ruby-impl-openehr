require 'shared_token_grammar'
require 'open_ehr/assumed_library_types'
require 'open_ehr/am/archetype/constraint_model'

module OpenEHR
  module Parser
    grammar CADL
#      include SharedToken
#      include OpenEHR::AssumedLibraryTypes
#      include OpenEHR::AM::Archetype::ConstraintModel

      rule V_CADL_TEXT
        c_complex_object '' {
          def value	    
            c_complex_object.value
          end
        }
      / assertions '' {
          def value
            assertions.value
          end
        }
      end

      rule c_complex_object
        head:c_complex_object_head SYM_MATCHES SYM_START_CBLOCK body:c_complex_object_body SYM_END_CBLOCK {
          def value
            head.value.store(:children, body.value)
          end
        }
      / c_complex_object_head '' {
          def value
            c_complex_object_head.value
          end
        }
      end

      rule c_complex_object_head
        c_complex_object_id c_occurrences {
          def value
            c_complex_object_id.value.update occurrences.value
          end
        }
      / c_complex_object_id '' {
          def value
            c_complex_object_id.value
          end
        }
      end

      rule c_complex_object_id
        ti:type_identifier lo:V_LOCAL_TERM_CODE_REF space {
          def value
            {:rm_type_name => ti.value,
             :node_id => lo.value}
          end
        }
      / ti:type_identifier space {
          def value
            {rm_type_name => ti.value}
          end
        }
      end

      rule c_complex_object_body
        c_any '' {
          def value
            [:any_allowed? => true]
          end
        }
      / c_attributes '' {
          def value
            c_attributes.value + [Hash.new(:any_allowed? => false)]
          end
        }
      end

      rule c_object
        c_complex_object '' {
          def value
            c_complex_object.value
          end
        }
      / archetype_slot '' {
          def value
            archetype_slot.value
          end
        }
      / archetype_internal_ref '' {
          def value
            archetype_internal_ref.value
          end
        }
      / constraint_ref '' {
          def value
            constraint_ref.value
          end
        }
      / c_primitive_object '' {
          def value
            c_primitive_object.value
          end
        }
      / V_C_DOMAIN_TYPE '' {
          def value
            p elemetns
          end
        }
#     / ERR_V_C_DOMAIN_TYPE
      end

      rule archetype_internal_ref
        SYM_USE_NODE type_identifier c_occurrences object_path {
          def value
            {:id => type_identifier.value, :occurrences => c_occurrences.value,
             :path => object_path}
          end
        }
      / SYM_USE_NODE type_identifier object_path {
          def value
            {:id => type_identifier.value, :path => object_path}
           end
        }
      end

      rule archetype_slot
        c_archetype_slot_head SYM_MATCHES SYM_START_CBLOCK c_includes c_excludes SYM_END_CBLOCK {
          def value
            {:includes => c_includes.value,
             :excludes => c_excludes.value}
          end
        }
      / c_archetype_slot_head SYM_MATCHES SYM_START_CBLOCK c_includes SYM_END_CBLOCK {
          def value
            {:includes => c_includes.value}
          end
        }
      / c_archetype_slot_head SYM_MATCHES SYM_START_CBLOCK c_excludes SYM_END_CBLOCK {
          def value
            {:excludes => c_excludes.value}
          end
        }
      end

      rule c_archetype_slot_head
        c_archetype_slot_id white_space c_occurrences {
          def value
            c_archetype_slot_id.value.update c_occurrences.value
          end
        }
      / c_archetype_slot_id white_space {
          def value
            c_archetype_slot_id.value
          end
        }
      end

      rule c_archetype_slot_id
        SYM_ALLOW_ARCHETYPE type_identifier V_LOCAL_TERM_CODE_REF {
          def value
            {:type =>type_identifier.value, :ref => V_LOCAL_TERM_CODE_REF.value}
          end
        }
      / SYM_ALLOW_ARCHETYPE type_identifier {
          def value
            {:type => type_identifier.value}
          end
        }
      end

      rule c_primitive_object
        c_primitive '' {
          def value
            c_primitive.value
          end
        }
      end

      rule c_primitive
        c_integer '' {
          def value
            c_integer.value
          end
        }	
      / c_real '' {
          def value
            c_real.value
          end
        }
      / c_date '' {
          def value
            c_date.value
          end
        }
      / c_time '' {
          def value
            c_time.value
          end
        }
      / c_date_time '' {
          def value
            c_date_time.value
          end
        }
      / c_duration '' {
          def value
            c_duration.value
          end
        }
      / c_string '' {
          def value
            c_string.value
          end
        }
      / c_boolean '' {
          def value
            c_boolean.value
          end
        }
      end

      rule c_any
        '*' space
      end

      rule c_attributes
        c_attribute more_attr:(c_attribute)* {
          def value
            attributes.map {|c| c.value}
          end

          def attributes
            [c_attribute] + more_attr.elements.map {|e| e.attribute}
          end
        }
      end

      rule c_attribute
        c_attr_head c_attr_body {
          def value
            {:rm_attribute_name => c_attr_head.value[:id],
             :existence => c_attr_head.value[:existence],
             :cardinality => c_attr_head.value[:cardinality],
             :children => c_attr_body.value}
          end
        }
      end

      rule c_attr_head
        id:(V_ATTRIBUTE_IDENTIFIER) white_space c_existence c_cardinality {
          def value
            {:id => id.value,
             :existence => c_existence.value,
             :cardinality => c_cardinality.value}
          end
        }
      / id:V_ATTRIBUTE_IDENTIFIER white_space c_existence {
          def value
            {:id => id.value, :existence => c_existence.value}
          end
        }
      / id:(V_ATTRIBUTE_IDENTIFIER) white_space c_cardinality {
          def value
            {:id => id.value, :cardinality => c_cardinality.value}
          end
        }
      / id:(V_ATTRIBUTE_IDENTIFIER) white_space {
          def value
            {:id => id.value}
          end
        }
      end

      rule c_attr_body
        SYM_MATCHES SYM_START_CBLOCK c_attr_values SYM_END_CBLOCK {
          def value
            c_attr_values.value
          end
        }
      end

      rule c_attr_values
        c_any '' {
          def value
            c_any.value
          end
        }
      / c_object more_co:(c_object '')* {
          def value
            c_objects.map {|c| c.value}
          end

          def c_objects
            [c_object] + more_co.elements.map {|e| e.c_object }
          end
        }
      end

      rule c_includes
        SYM_INCLUDE assertions {
          def value
            assertions.value
          end
        }
      end

      rule c_excludes
        SYM_EXCLUDE assertions {
          def value
            assertions.value
          end
        }
      end

      rule c_existence
        SYM_EXISTENCE SYM_MATCHES SYM_START_CBLOCK existence_spec SYM_END_CBLOCK {
          def value
            existence_spec.value
          end
        }
      end

      rule existence_spec
        lo:V_INTEGER SYM_ELLIPSIS up:V_INTEGER {
          def value
            OpenEHR::AssumedTypesLibrary::Interval.new(:lower => lo.value, :upper => up.value)
          end
        }
      / V_INTEGER '' {
          def value
            OpenEHR::AssumedTypesLibrary::Interval.new(:lower => V_INTEGER.value, :upper => V_INTEGER.value)
          end
        }
      end

      rule c_cardinality
        SYM_CARDINALITY SYM_MATCHES SYM_START_CBLOCK cardinality_spec SYM_END_CBLOCK {
          def value
            cardinality_spec.value
          end
        }
      end

      rule cardinality_spec
        occurrence_spec ';' white_space SYM_ORDERED ';' white_space SYM_UNIQUE {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(:interval => occurrence_spec.value,
                            :is_unique => true,
                            :is_orderd => true)
          end
        }
      / occurrence_spec ';' white_space SYM_ORDERED {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(:interval => occurrence_spec.value,
                            :is_orderd => true)
          end
        }
      / occurrence_spec ';' white_space SYM_UNORDERD ';' white_space SYM_UNIQUE {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(:interval => occurrence_spec.value,
                            :is_unique => true,
                            :is_orderd => false)
          end
        }
      / occurrence_spec ';' white_space SYM_UNORDERD {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(:interval => occurrence_spec.value,
                            :is_orderd => false)
          end
        }
      / occurrence_spec SYM_UNIQUE ';' white_space SYM_ORDERED {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(:interval => occurrence_spec.value,
                            :is_unique => true,
                            :is_orderd => true)
          end
        }
      / occurrence_spec SYM_UNIQUE ';' white_space SYM_UNORDERD {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(:interval => occurrence_spec.value,
                            :is_unique => true,
                            :is_ordered => false)
          end
        }
      / occurrence_spec SYM_UNIQUE {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(:interval => occurrence_spec.value,
                            :is_unique => true)
          end
        }
      end

      rule c_occurrences
        SYM_OCCURRENCES SYM_MATCHES SYM_START_CBLOCK occurrence_spec SYM_END_CBLOCK {
          def value
            occurrence_spec.value
          end
        }
      end

      rule occurrence_spec
        st:(V_INTEGER) SYM_ELLIPSIS ed:cardinality_limit_value {
          def value
            if ed.value == '*'
              interval = OpenEHR::AssumedLibraryTypes::Interval.new(:lower => st.value,
                                      :upper_unbounded => true)
            else
              interval = OpenEHR::AssumedLibraryTypes::Interval.new(:lower => st.value,
                                      :upper => ed.value)
            end
          end
        }
      / cardinality_limit_value '' {
          def value
            OpenEHR::AssumedLibraryTypes::Interval.new(:lower => cardinality_limit_value.value,
                         :upper => cardinality_limit_value.value)
          end
        }
      end

      rule cardinality_limit_value
        integer_value {
          def value
            text_value.to_i
          end
        }
      / '*' {
          def value
            '*'
          end
        }
      end

      rule c_integer_spec
        cardinality_limit_value '' {
          def value
            cardinality_limit_value.value
          end
        }
      / integer_list_value '' {
          def value
            integer_list_value.value
          end
        }
      / integer_interval_value '' {
          def value
            integer_interval_value.value
          end
        }
      / occurrence_spec {
          def value
            occurrence_spec.value
          end
        }
      end

      rule c_integer
        c_integer_spec (';' integer_value)?
      end

      rule c_real_spec
        real_value
      / real_list_value
      / real_interval_value
      end

      rule c_real
        c_real_spec (';' real_value)?
      end

      rule c_date_constraint
        V_ISO8601_DATE_CONSTRAINT_PATTERN
      / date_value
      / date_interval_value
      end

      rule c_date
        c_date_constraint (';' date_value)?
      end

      rule c_time_constraint
        V_ISO8601_TIME_CONSTRAINT_PATTERN
      / time_value
      / time_interval_value
      end

      rule c_time
        c_time_constraint (';' time_value)?
      end

      rule c_date_time_constraint
        V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN
      / date_time_value
      / date_time_interval_value
      end

      rule c_date_time
        c_date_time_constraint
      / c_date_time_constraint ';' date_time_value
      end

      rule c_duration_constraint
        duration_pattern ('/' duration_interval_pattern)?
      / duration_value
      / duration_interval_value
      end

      rule duration_pattern
        V_ISO8601_TIME_CONSTRAINT_PATTERN
      end

      rule c_duration
        c_duration_constraint (';' duration_value)?
      end

      rule c_string_spec
        string_list_value ',' SYM_LIST_CONTINUE {
          def value
            string_list_value.value
          end
        }
      / string_list_value '' {
          def value
            string_list_value.value
          end
        }
      / V_REGEXP '' {
          def value
            V_REGEXP.value
          end
        }
      / V_STRING '' {
          def value
            V_STRING.value
          end
        }
      end

      rule c_string
        c_string_spec (';' string_value)? {
          def value
          end
        }
      end

      rule c_boolean_spec
        SYM_TRUE (',' SYM_FALSE)?
      / SYM_FALSE (',' SYM_TRUE)?
      end

      rule c_boolean
        c_boolean_spec ';' boolean_value {
          def value
            
          end
        }
      / c_boolean_spec '' {
          def value
            c_boolean_spec.value
          end
        }
      end

      rule constraint_ref
        V_LOCAL_TERM_CODE_REF '' {
          def value
            V_LOCAL_TERM_CODE_REF.value
          end
        }
      end

      rule V_REGEXP
        (('=' / '!') '~')? (('/' ('\/' / !'/' .)* '/') / ('^' (!'^' .)* '^') ) {
          def value
            text_value
          end
        }      
      end

      rule V_C_DOMAIN_TYPE
        '('? [A-Z] IDCHAR* ')'? [ \n]* '<' [^>]* '>'
      end

# assertion block

      rule V_ASSERTION_TEXT
        assertions '' {
          def value
            elements
          end
        }
      end

      rule assertions
        assertion+ {
          def value
            elements.map {|e| e.value}
          end
        }
      end

      rule assertion
        id:(any_identifier ':')? boolean_expression space {
          def value
            if (id && !id.empty?)
              {:tag => id.value, :expression => boolean_expression.value}
            else
              {:expression => boolean_expression.value}
            end
          end
        }
      end

      rule boolean_expression
        boolean_node '' {
          def value
            {:type => 'Boolean', :value => boolean_node.value}
          end
        }
      end

      rule boolean_node
        SYM_EXISTS absolute_path {
          def value
            {:operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_EXISTS,
             :path => absolute_path.value }
          end
        }
      / relative_path white_space SYM_MATCHES SYM_START_CBLOCK c_primitive SYM_END_CBLOCK {
          def value
            {:path => relative_path.value, :children => c_primitive.value}
          end
        }
      / SYM_NOT boolean_leaf {
          def value
            boolean_leaf.value
          end
        }
      / arithmetic_expression (SYM_EQ / SYM_NE / SYM_LT / SYM_GT / SYM_LE / SYM_GE) arithmetic_expression {
          def value
            p elements
          end
        }
      / boolean_leaf ((SYM_AND / SYM_OR / SYM_XOR / SYM_IMPLIES) boolean_leaf)? {
          def value
            p elements
          end
        }
      end

      rule boolean_leaf
        '(' boolean_expression ')' {
          def value
            boolean_expression.value
          end
        }
      / SYM_TRUE {
          def value
            true
          end
        }
      / SYM_FALSE {
          def value
            false
          end
        }
      end

      rule arithmetic_expression
        arithmetic_node '' {
          def value
            arithmetic_node.value
          end
        }
      end

      rule arithmetic_node
        arithmetic_leaf (('+' / '-' / '*' / '/' / '^') arithmetic_leaf)*
      end

      rule arithmetic_leaf
       '(' arithmetic_expression ')' {
          def value
            arithmetic_expression.value
          end
        }
      / integer_value '' {
          def value
            integer_value.value
          end
        }
      / real_value '' {
          def value
            real_value.value
          end
        }
      / absolute_path '' {
          def value
            absolute_path.value
          end
        }
      end

# path block
      rule movable_path
         SYM_MOVABLE_LEADER relative_path {
           def value
             text_value
           end
         }
      end

      rule absolute_path
        '/' relative_path? {
           def value
             text_value
           end
         }
      end

      rule relative_path
        path_segment ('/' path_segment)* {
          def value
            text_value
          end
        }
      end

      rule path_segment
        V_ATTRIBUTE_IDENTIFIER V_LOCAL_TERM_CODE_REF? {
          def value
            text_value
          end
        }
      end

      rule SYM_MOVABLE_LEADER
        '//'
      end
    end
  end
end