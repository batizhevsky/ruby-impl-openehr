require 'shared_token_grammar'
require 'open_ehr/assumed_library_types'
require 'open_ehr/am/archetype/constraint_model'
require 'cadl_node'

module OpenEHR
  module Parser
    grammar CADL
#      include OpenEHR::Parser::CADL

      rule V_CADL_TEXT
        c_complex_object '' {
          def value
            c_complex_object.value
          end
        }
      / assertions '' {
          def value
            assertions.value
          end
        }
      end

      rule c_complex_object
        head:c_complex_object_head SYM_MATCHES SYM_START_CBLOCK body:c_complex_object_body SYM_END_CBLOCK space {
          def value(node = ArchetypeNode.new)
            args = head.value
            args[:occurrences] ||= OpenEHR::AssumedLibraryTypes::Interval.new(
              :lower => 1, :upper => 1)
            node.id = args[:node_id]
            if node.root? or node.id.nil?
              args[:path] = node.path
            else
              args[:path] = node.path + '[' + node.id + ']'
            end
            args.update body.value(node)
            OpenEHR::AM::Archetype::ConstraintModel::CComplexObject.new(args)
          end
        }
      / c_complex_object_head '' {
          def value(node = ArchetypeNode.new)
            args = c_complex_object_head.value
            args[:occurrences] ||= OpenEHR::AssumedLibraryTypes::Interval.new(
              :lower => 1, :upper => 1)
            node.id = args[:node_id]
            args[:path] = node.path
            OpenEHR::AM::Archetype::ConstraintModel::CComplexObject.new(args)
          end
        }
      end

      rule c_complex_object_head
        c_complex_object_id c_occurrences {
          def value
            c_complex_object_id.value[:occurrences] = c_occurrences.value
            c_complex_object_id.value
          end
        }
      / c_complex_object_id '' {
          def value
            c_complex_object_id.value
          end
        }
      end

      rule c_complex_object_id
        ti:type_identifier lo:V_LOCAL_TERM_CODE_REF space {
          def value
            {:rm_type_name => ti.value,
             :node_id => lo.value}
          end
        }
      / ti:type_identifier space {
          def value
            {:rm_type_name => ti.value}
          end
        }
      end

      rule c_complex_object_body
        c_any '' {
          def value(node)
            Hash[:attributes => c_any.value(node)]
          end
        }
      / c_attributes '' {
          def value(node)
            Hash[:attributes => c_attributes.value(node)]
          end
        }
      end

      rule c_object
        c_primitive_object '' {
          def value(node)
            c_primitive_object.value
          end
        }
      /  c_complex_object '' {
          def value(node)
            c_complex_object.value(node)
          end
        }
      / constraint_ref '' {
          def value(node = nil)
            constraint_ref.value
          end
        }
      / archetype_slot '' {
          def value(node)
            archetype_slot.value(node)
          end
        }
      / archetype_internal_ref '' {
          def value(node = nil)
            archetype_internal_ref.value(node)
          end
        }
      / V_C_DOMAIN_TYPE '' {
          def value(node = nil)
            p elemetns
          end
        }
#     / ERR_V_C_DOMAIN_TYPE
      end

      rule archetype_internal_ref
        SYM_USE_NODE type_identifier c_occurrences object_path space {
          def value(node)
            OpenEHR::AM::Archetype::ConstraintModel::ArchetypeInternalRef.new(
              :rm_type_name => type_identifier.value,
              :occurrences => c_occurrences.value,
              :path => node.path,
              :target_path => object_path.value)
          end
        }
      / SYM_USE_NODE type_identifier object_path space {
          def value(node = nil)
            OpenEHR::AM::Archetype::ConstraintModel::ArchetypeInternalRef.new(
              :rm_type_name => type_identifier.value,
              :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => 1, :upper => 1),
              :path => node.path,
              :target_path => object_path.value)
           end
        }
      end

      rule archetype_slot
        c_archetype_slot_head SYM_MATCHES SYM_START_CBLOCK c_includes c_excludes SYM_END_CBLOCK space {
          def value(node)
            args = c_archetype_slot_head.value(node)
            args[:includes] = c_includes.value
            args[:excludes] = c_excludes.value
            OpenEHR::AM::Archetype::ConstraintModel::ArchetypeSlot.new(args)
          end
        }
      / c_archetype_slot_head SYM_MATCHES SYM_START_CBLOCK c_includes SYM_END_CBLOCK space {
          def value(node)
            args = c_archetype_slot_head.value(node)
            args[:includes] = c_includes.value
            OpenEHR::AM::Archetype::ConstraintModel::ArchetypeSlot.new(args)
          end
        }
      / c_archetype_slot_head SYM_MATCHES SYM_START_CBLOCK c_excludes SYM_END_CBLOCK space {
          def value(node)
            args = c_archetype_slot_head.value(node)
            args[:excludes] = c_excludes.value
            OpenEHR::AM::Archetype::ConstraintModel::ArchetypeSlot.new(args)
          end
        }
      end

      rule c_archetype_slot_head
        c_archetype_slot_id white_space c_occurrences {
          def value(node)
            args = c_archetype_slot_id.value(node)
            args[:occurrences] = c_occurrences.value
            args
          end
        }
      / c_archetype_slot_id white_space {
          def value(node)
            c_archetype_slot_id.value
          end
        }
      end

      rule c_archetype_slot_id
        SYM_ALLOW_ARCHETYPE type_identifier lt:V_LOCAL_TERM_CODE_REF {
          def value(node)
            {:rm_type_name => type_identifier.value,
             :node_id => lt.value,
             :path => node.path + "[#{lt.value}]"}
          end
        }
      / SYM_ALLOW_ARCHETYPE type_identifier {
          def value(node)
            {:rm_type_name => type_identifier.value,
             :path => node.path}
          end
        }
      end

      rule c_primitive_object
        c_primitive '' {
          def value
            c_primitive.value
          end
        }
      end

      rule c_primitive
        c_date_time '' {
          def value
            c_date_time.value
          end
        }
      / c_time '' {
          def value
            c_time.value
          end
        }
      / c_date '' {
          def value
            c_date.value
          end
        }
      / c_duration '' {
          def value
            c_duration.value
          end
        }
      / c_real '' {
          def value
            c_real.value
          end
        }
      / c_integer '' {
          def value
            c_integer.value
          end
        }	
      / c_boolean '' {
          def value
            c_boolean.value
          end
        }
      / c_string '' {
          def value
            c_string.value
          end
        }
      end

      rule c_any
        '*' space {
          def value(node)
            OpenEHR::AM::Archetype::ConstraintModel::CAttribute.new(
              :path => node.path, :rm_attribute_name => node.id,
              :exsitence => OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => 1, :upper => 1))
          end
        }
      end

      rule c_attributes
        c_attribute more_attr:(c_attribute white_space)* {
          def value(node)
            attributes.map {|c| c.value(node)}
          end

          def attributes
            [c_attribute] + more_attr.elements.map {|e| e.c_attribute}
          end
        }
      end

      rule c_attribute
        c_attr_head c_attr_body {
          def value(node)
            val = c_attr_head.value(node)
            child_node = ArchetypeNode.new(node)
            child_node.path = val.path
            val.children = c_attr_body.value(child_node)
            val
          end
        }
      end

      rule c_attr_head
        id:(V_ATTRIBUTE_IDENTIFIER) white_space c_existence c_cardinality {
          def value(node)
            if node.root?
              path = node.path + id.value
            elsif node.id
              path = node.path + "[#{node.id}]/" + id.value
            elsif
              path = node.path + '/' + id.value
            end
            OpenEHR::AM::Archetype::ConstraintModel::CMultipleAttribute.new(
             :rm_attribute_name => id.value,
             :path => path,
             :existence => c_existence.value,
             :cardinality => c_cardinality.value)
          end
        }
      / id:V_ATTRIBUTE_IDENTIFIER white_space c_existence {
          def value(node)
            if node.root?
              path = node.path + id.value
            elsif node.id
              path = node.path + "[#{node.id}]/" + id.value
            elsif
              path = node.path + '/' + id.value
            end
            OpenEHR::AM::Archetype::ConstraintModel::CSingleAttribute.new(
             :rm_attribute_name => id.value,
             :path => path,
             :existence => c_existence.value)
          end
        }
      / id:(V_ATTRIBUTE_IDENTIFIER) white_space c_cardinality {
          def value(node)
            if node.root?
              path = node.path + id.value
            elsif node.id
              path = node.path + "[#{node.id}]/" + id.value
            elsif
              path = node.path + '/' + id.value
            end
            OpenEHR::AM::Archetype::ConstraintModel::CMultipleAttribute.new(
             :rm_attribute_name => id.value,
             :path => path,
             :cardinality => c_cardinality.value)
          end
        }
      / id:(V_ATTRIBUTE_IDENTIFIER) white_space {
          def value(node)
            if node.root?
              path = node.path + id.value
            elsif node.id
              path = node.path + "[#{node.id}]/" + id.value
            elsif
              path = node.path + '/' + id.value
            end
            OpenEHR::AM::Archetype::ConstraintModel::CSingleAttribute.new(
             :rm_attribute_name => id.value, :path => path)
          end
        }
      end

      rule c_attr_body
        SYM_MATCHES SYM_START_CBLOCK c_attr_values SYM_END_CBLOCK space {
          def value(node)
            c_attr_values.value(node)
          end
        }
      end

      rule c_attr_values
        c_any '' {
          def value(node)
            c_any.value
          end
        }
      / c_object more_co:(c_object '')* {
          def value(node)
            c_objects.map {|c| c.value(node)}
          end

          def c_objects
            [c_object] + more_co.elements.map {|e| e.c_object }
          end
        }
      end

      rule c_includes
        SYM_INCLUDE assertions {
          def value
            assertions.value
          end
        }
      end

      rule c_excludes
        SYM_EXCLUDE assertions {
          def value
            assertions.value
          end
        }
      end

      rule c_existence
        SYM_EXISTENCE SYM_MATCHES SYM_START_CBLOCK existence_spec SYM_END_CBLOCK space {
          def value
            existence_spec.value
          end
        }
      end

      rule existence_spec
        lo:V_INTEGER SYM_ELLIPSIS up:V_INTEGER {
          def value
            OpenEHR::AssumedTypesLibrary::Interval.new(:lower => lo.value, :upper => up.value)
          end
        }
      / V_INTEGER '' {
          def value
            OpenEHR::AssumedTypesLibrary::Interval.new(:lower => V_INTEGER.value, :upper => V_INTEGER.value)
          end
        }
      end

      rule c_cardinality
        SYM_CARDINALITY SYM_MATCHES SYM_START_CBLOCK cardinality_spec SYM_END_CBLOCK space {
          def value
            cardinality_spec.value
          end
        }
      end

      rule cardinality_spec
        occurrence_spec ';' white_space SYM_ORDERED ';' white_space SYM_UNIQUE {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
              :interval => occurrence_spec.value,
              :is_unique => true,
              :is_orderd => true)
          end
        }
      / occurrence_spec ';' white_space SYM_ORDERED {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
              :interval => occurrence_spec.value,
              :is_orderd => true)
          end
        }
      / occurrence_spec ';' white_space SYM_UNORDERD ';' white_space SYM_UNIQUE {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
              :interval => occurrence_spec.value,
              :is_unique => true,
              :is_orderd => false)
          end
        }
      / occurrence_spec ';' white_space SYM_UNORDERD {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
              :interval => occurrence_spec.value,
              :is_orderd => false)
          end
        }
      / occurrence_spec SYM_UNIQUE ';' white_space SYM_ORDERED {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
              :interval => occurrence_spec.value,
              :is_unique => true,
              :is_orderd => true)
          end
        }
      / occurrence_spec SYM_UNIQUE ';' white_space SYM_UNORDERD {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
              :interval => occurrence_spec.value,
              :is_unique => true,
              :is_ordered => false)
          end
        }
      / occurrence_spec SYM_UNIQUE {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
              :interval => occurrence_spec.value,
              :is_unique => true)
          end
        }
      end

      rule c_occurrences
        SYM_OCCURRENCES SYM_MATCHES SYM_START_CBLOCK occurrence_spec SYM_END_CBLOCK space {
          def value
            occurrence_spec.value
          end
        }
      end

      rule occurrence_spec
        st:integer_value SYM_ELLIPSIS ed:cardinality_limit_value {
          def value
            if ed.value == '*'
              interval = OpenEHR::AssumedLibraryTypes::Interval.new(
                 :lower => st.value,
                 :upper_unbounded => true)
            else
              interval = OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => st.value,
                :upper => ed.value)
            end
          end
        }
      / cardinality_limit_value '' {
          def value
            OpenEHR::AssumedLibraryTypes::Interval.new(
              :lower => cardinality_limit_value.value,
              :upper => cardinality_limit_value.value)
          end
        }
      end

      rule cardinality_limit_value
        integer_value '' {
          def value
            text_value.to_i
          end
        }
      / '*' {
          def value
            '*'
          end
        }
      end

      rule c_integer
        c_integer_spec ';' white_space integer_value {
          def value
            args = c_integer_spec.value
            args[:assumed_value] = integer_value.value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CInteger.new(args)
          end
        }
      / c_integer_spec '' {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CInteger.new(
              c_integer_spec.value)
          end
        }
      end

      rule c_integer_spec
        integer_list_value '' {
          def value
            {:list => integer_list_value.value}
          end
        }
      / integer_interval_value '' {
          def value
            {:range => integer_interval_value.value}
          end
        }
      / integer_value !'..' '' {
          def value
            {:list => [integer_value.value]}
          end
        }
      / occurrence_spec '' {
          def value
            {:range => occurrence_spec.value}
          end
        }
      end

      rule c_real_spec
        real_list_value '' {
          def value
            {:list => real_list_value.value}
          end
        }
      / real_interval_value '' {
          def value
            {:range => real_interval_value.value}
          end
        }
      / real_value '' {
          def value
            {:list => [real_value.value]}
          end
        }
      end

      rule c_real
        c_real_spec ';' white_space real_value {
          def value
            args = c_real_spec.value
            args[:assumed_value] = real_value.value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CReal.new(args)
          end
        }
      / c_real_spec '' {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CReal.new(
              c_real_spec.value)
          end
        }
      end

      rule c_date_constraint
        date_interval_value '' {
          def value
            date_interval_value.value
          end
        }
      / date_value '' {
          def value
            date_value.value
          end
        }
      / con:V_ISO8601_DATE_CONSTRAINT_PATTERN '' {
          def value
            {:pattern => con.text_value}
          end
        }
      end

      rule c_date
        c_date_constraint ';' white_space date_value {
          def value
            c_date_constraint.value
          end
        }
      / c_date_constraint '' {
          def value
            c_date_constraint.value
          end
        }
      end

      rule c_time_constraint
        time_interval_value '' {
          def value
            time_interval_value.value
          end
        }
      / time_value '' {
          def value
            time_value.value
          end
        }
      / tc:V_ISO8601_TIME_CONSTRAINT_PATTERN '' {
          def value
            {:pattern => tc.text_value}
          end
        }
      end

      rule c_time
        c_time_constraint ';' white_space time_value {
          def value
            c_time_constraint.value
          end
        }    
      / c_time_constraint '' {
          def value
            c_time_constraint.value
          end
        }
      end

      rule c_date_time_constraint
        date_time_interval_value '' {
          def value
            date_time_interval_value.value
          end
        }
      / date_time_value '' {
          def value
            date_time_value.value
          end
        }
      / dtc:V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN '' {
          def value
            {:pattern => dtc.text_value}
          end
        }
      end

      rule c_date_time
        c_date_time_constraint ';' white_space date_time_value {
          def value
            c_date_time_constraint.value
          end
        }
      / c_date_time_constraint '' {
          def value
            c_date_time_constraint.value
          end
        }
      end

      rule c_duration_constraint
        duration_pattern '' {
          def value
            duration_pattern.value
          end
        }
      / duration_pattern '/' duration_interval_value '' {
          def value
            duration_pattern.value
          end
        }
      / duration_interval_value '' {
          def value
            duration_interval_value.value
          end
        }
      / duration_value '' {
          def value
            duration_value.value
          end
        }
      end

      rule duration_pattern
        V_ISO8601_DURATION_CONSTRAINT_PATTERN '' {
          def value
            V_ISO8601_DURATION_CONSTRAINT_PATTERN.value
          end
        }
      end

      rule c_duration
        c_duration_constraint ';' white_space duration_value {
          def value
            c_duration_constraint.value
          end
        }
      / c_duration_constraint '' {
          def value
            c_duration_constraint.value
          end
        }
      end

      rule c_string_spec
        string_list_value ',' SYM_LIST_CONTINUE {
          def value
            {:list => string_list_value.value}
          end
        }
      / string_list_value '' {
          def value
            {:list => string_list_value.value}
          end
        }
      / pat:V_REGEXP '' {
          def value
            {:pattern => pat.value}
          end
        }
      / str:V_STRING '' {
          def value
            {:list => [str.value]}
          end
        }
      end

      rule c_string
        c_string_spec white_space ';' white_space string_value {
          def value
            args = c_string_spec.value
            args[:assumed_value] = string_value.value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CString.new(
              args)
          end
        }
      / c_string_spec '' {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CString.new(
              c_string_spec.value)
          end
        }
      end

      rule c_boolean_spec
        SYM_TRUE ',' white_space SYM_FALSE {
          def value
            {:true_valid => true, :false_valid => true}
          end
        }
      / SYM_TRUE white_space '' {
          def value
            {:true_valid => true, :false_valid => false}
          end
        }
      / SYM_FALSE white_space ',' white_space SYM_TRUE {
          def value
            {:true_valid => true, :false_valid => true}
          end
        }
      / SYM_FALSE white_space '' {
          def value
            {:false_valid => true, :true_valid => false}
          end
        }
      end

      rule c_boolean
        c_boolean_spec ';' white_space boolean_value {
          def value
            args = c_boolean_spec.value
            args[:assumed_value] = boolean_value.value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CBoolean.new(
              args)
          end
        }
      / c_boolean_spec '' {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::Primitive::CBoolean.new(
              c_boolean_spec.value)
          end
        }
      end

      rule constraint_ref
        V_LOCAL_TERM_CODE_REF '' {
          def value
            V_LOCAL_TERM_CODE_REF.value
          end
        }
      end

      rule V_REGEXP
        (('=' / '!') '~')? (('/' ('\/' / !'/' .)* '/') / ('^' (!'^' .)* '^') ) {
          def value
            text_value
          end
        }      
      end

      rule V_C_DOMAIN_TYPE
        '('? [A-Z] IDCHAR* ')'? [ \n]* '<' [^>]* '>'
      end

# assertion block

      rule V_ASSERTION_TEXT
        assertions '' {
          def value
            assertions.value
          end
        }
      end

      rule assertions
        assertion more_a:(assertion '')* {
          def value
            assertions.map {|a| a.value}
          end

          def assertions
            [assertion] + more_a.elements.map {|a| a.assertion}
          end
        }
      end

      rule assertion
        id:(any_identifier ':')? boolean_expression space {
          def value
            if (id && !id.empty?)
              OpenEHR::AM::Archetype::Assertion::Assertion.new(
                :tag => id.value, :expression => boolean_expression.value,
                :string_expression => id.text_value + boolean_expression.text_value)
            else
              OpenEHR::AM::Archetype::Assertion::Assertion.new(
                :expression => boolean_expression.value,
                :string_expression => boolean_expression.text_value)
            end
          end
        }
      end

      rule boolean_expression
        boolean_node '' {
          def value
            boolean_node.value
          end
        }
      / boolean_leaf '' {
          def value
            boolean_leaf.value
          end
        }
      end

      rule boolean_node
        SYM_EXISTS absolute_path {
          def value
            item = OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
              :type => 'String',
              :item => absolute_path.value,
              :reference_type => 'CONSTANT')
            OpenEHR::AM::Archetype::Assertion::ExprUnaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_EXISTS,
              :operand => item,
              :precedence_overridden => false)
          end
        }
      / relative_path white_space SYM_MATCHES SYM_START_CBLOCK c_primitive SYM_END_CBLOCK {
          def value
            left_op = OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
                        :type => 'String',
                        :item => relative_path.value,
                        :reference_type => 'Constant')
            right_op = OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
                        :item => c_primitive.value,
                        :type => c_primitive.value.type,
                        :reference_type => 'Constant')
            op = OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_MATCHES
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => op,
              :right_operand => right_op,
              :left_operand => left_op,
              :reference_type => 'Constraint')
          end
        }
      / SYM_NOT boolean_leaf {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprUnaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_NOT,
              :operand => boolean_leaf.value,
              :precedence_overridden => false)
          end
        }
      / arithmetic_leaf SYM_EQ arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_EQ,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf SYM_NE arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_NE,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf SYM_LT arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_LT,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf SYM_GT arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_GT,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf SYM_LE arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_LE,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf SYM_GE arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_GE,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / boolean_leaf SYM_AND boolean_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_AND,
              :left_operand => boolean_leaf.value,
              :right_operand => boolean_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / boolean_leaf SYM_OR boolean_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_OR,
              :left_operand => boolean_leaf.value,
              :right_operand => boolean_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / boolean_leaf SYM_XOR boolean_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_XOR,
              :left_operand => boolean_leaf.value,
              :right_operand => boolean_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / boolean_leaf SYM_IMPLIES boolean_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_IMPLIES,
              :left_operand => boolean_leaf.value,
              :right_operand => boolean_expression.value,
              :reference_type => 'Constraint')
          end
        }
      end

      rule boolean_leaf
        '(' boolean_expression ')' {
          def value
            boolean_expression.value
          end
        }
      / SYM_TRUE {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
              :type => 'Boolean',
              :item => true,
              :reference_type => 'CONSTANT')
          end
        }
      / SYM_FALSE {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
              :type => 'Boolean',
              :item => false,
              :reference_type => 'CONSTANT')
          end
        }
      end

      rule arithmetic_expression
        arithmetic_node '' {
          def value
            arithmetic_node.value
          end
        }
      / arithmetic_leaf '' {
          def value
            arithmetic_leaf.value
          end
        }
      end

      rule arithmetic_node
        arithmetic_leaf '+' arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_PLUS,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf '-' arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_MINUS,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf '*' arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_MULTIPLY,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf '/' arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_DIVIDE,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      / arithmetic_leaf '^' arithmetic_expression {
          def value
            OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
              :type => 'Boolean',
              :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_EXP,
              :left_operand => arithmetic_leaf.value,
              :right_operand => arithmetic_expression.value,
              :reference_type => 'Constraint')
          end
        }
      end

      rule arithmetic_leaf
       '(' arithmetic_expression ')' space {
          def value
            arithmetic_expression.value
          end
        }
      / integer_value '' {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::ExprLeaf.new(
              :type => 'Integer',
              :item => integer_value.value,
              :reference_type => 'CONSTANT')
          end
        }
      / real_value '' {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::ExprLeaf.new(
              :type => 'Real',
              :item => real_value.value,
              :reference_type => 'CONSTANT')
          end
        }
      / absolute_path space {
          def value
            OpenEHR::AM::Archetype::ConstraintModel::ExprLeaf.new(
              :type => 'String',
              :item => absolute_path.value,
              :reference_type => 'CONSTANT')
            
          end
        }
      end

# path block
      rule object_path
        movable_path '' {
          def value
            movable_path.value
          end
	}
      / absolute_path '' {
          def value
            absolute_path.value
          end
        }
      / relative_path '' {
          def value
            relative_path.value
          end
        }
      end

      rule movable_path
         SYM_MOVABLE_LEADER relative_path '' {
           def value
             text_value
           end
         }
      end

      rule absolute_path
        '/' relative_path? '' {
           def value
             text_value
           end
         }
      end

      rule relative_path
        path_segment ('/' path_segment)* '' {
          def value
            text_value
          end
        }
      end

      rule path_segment
        V_ATTRIBUTE_IDENTIFIER V_LOCAL_TERM_CODE_REF? '' {
          def value
            text_value
          end
        }
      end

      rule SYM_MOVABLE_LEADER
        '//'
      end
    end
  end
end